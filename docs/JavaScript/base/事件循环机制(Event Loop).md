---
theme: v-green
---

<!-- ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/250cc3f16a3443c1bb32b21c2b7aa128~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=916&h=940&s=65146&e=png&b=eeeff0) -->

![EventLoop](/JavaScript/EventLoop.jpg)

### 前置知识

说到 js 的事件循环机制（这里主要讨论的是浏览器中的事件循环），首先我们明确两个概念

1、JavaScript 是单线程语言

> 虽然 WebWorker 可以开启独立的线程执行 JavaScript 代码，但这并不影响“JavaScript 是单线程的”这一核心特点

2、浏览器是多线程的

> 浏览器的每个标签页都是一个独立的进程，在每个进程中又包括多个线程，如：JS 执行引擎闲线程、GUI 渲染线程、事件触发线程、定时器线程、网络请求线程...

### 事件循环（EventLoop）

#### 1、定义

事件循环总是以一个宏任务开始，执行过程中遇到**宏任务**和**微任务**会分别放入宏任务队列和微任务队列，继续执行，直到执行完所有同步代码执行栈清空后，检查微任务队列中是否有待执行的任务，如果有则取出所有微任务执行。等待微任务队列清空后，js 执行引擎线程（主线程）让出控制权交由 GUI 渲染线程进行页面渲染。至此，一个事件循环结束，从宏任务队列中取出下一个宏任务放入执行栈中执行，以此往复...

#### 2、宏任务（macrotask/task）

更准确的描述，执行过程中遇到宏任务时，它的回调函数会被放注册到**事件表**（EventTable）中，并由其他线程来执行异步处理，当异步处理完成时，从事件表中取出回调函数放入宏任务队列中等待执行。

例如下面代码 👇：

```js
setTimeout(function () {
  console.log("setTimeout");
}, 1000);

/**
1、在事件表中注册回调函数
2、由定时器线程（浏览器中）或工作线程（Node环境中）处理定时操作
3、1000ms后从事件表中取出回调函数放入宏任务队列中等待执行
*/
```

常见的宏任务：

- script 脚本
- setTimeout，setInterval，setImmediate（Node.js 环境）
- DOM 操作
- 网络任务
- 用户交互：DOM0 和 DOM2 级事件监听回调函数
- I/O

#### 3、微任务（microtask）

常见的微任务：

- Promise 的原型方法: then、catch、finally 中的回调函数
- MutationObserver（用于监听 DOM 节点变化）
- process.nextTick（Node.js 环境）

#### 4、事件表（EventTable）

- 事件表不是实际的数据结构，而是一个抽象概念，用于追踪异步操作（如 setTimeout, 文件读取等）
- 当一个异步函数被调用时，它的回调函数被注册到事件表中，并且异步操作开始执行
- 一旦异步操作完成（例如，时间到了，文件读取完毕等），回调函数被移动到任务队列（也称为消息队列或事件队列）

### 总结

1. js 是单线程的，浏览器是多线程的
2. 微任务的优先级高于宏任务，所以必要的时候可以将用微任务来处理
3. 定时器的定时并不是准确的，具体执行时间取决于主线程中的同步任务及微任务的执行耗时
4. GUI 渲染线程和 js 执行引擎线程的之间是互斥的。通常是在微任务队列清空&下一次宏任务执行之前，js 执行主线程让出控制权交由 GUI 渲染线程进行页面渲染（浏览器会评估是否需要）
